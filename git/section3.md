# Gitの仕組みと基本コマンド

Gitはファイルのバージョンを保存する際にそのファイル全てをスナップショットとして保存している。
<br>
[![Image from Gyazo](https://i.gyazo.com/603ed12c3fa7bee0c54ef51b7f41aab3.png)](https://gyazo.com/603ed12c3fa7bee0c54ef51b7f41aab3)
<br>

まず、その3つのファイルの状態をバージョン1として保存する　(まるまる保存する)

[![Image from Gyazo](https://i.gyazo.com/d9ad6639d19754f79e13312d78869b70.png)](https://gyazo.com/d9ad6639d19754f79e13312d78869b70)
<br>
ファイルの名前を画像のように保存する
その時の状態をバージョン2とする

この時、GitはファイルB1, ファイルC1はB,Cと差分を保存するのではなく
B1,C1をスナップショットとしてファイルを丸ごと保存している<br>
ファイルAは使い回す

[![Image from Gyazo](https://i.gyazo.com/70ba9bc5e8f99646f6f4c7aa9f45e5e7.png)](https://gyazo.com/70ba9bc5e8f99646f6f4c7aa9f45e5e7)
<br>
ファイルA1 , ファイルC2 : スナップショットとして丸ごと保存する<br>
ファイルB1: 使い回し

何故、スナップショットで保存するのか？
スナップショットで保存することで、複数人で開発する時のスピードを上げれる<br>
(brachを切ったり、mergeしやすくなる)

バージョンを記録することでできること
コミットを辿ることで、以前の状態に戻せる

## Gitの作業の流れ
ローカル(自分のパソコン)でスナップショットを記録 -> GitHub(自分のパソコンと別の場所)へアップロード

リポジトリ: 履歴データの置き場 , 履歴データの保管場所
ワーク: 作業場
ツリー: ディレクトリ , フォルダ

## 他人の変更を取り込む時
ローカルリポジトリにGithubの記録を取得 -> Githubの記録をワークツリーに反映させる

## ローカルは3つのエリアに分かれている
###### ワークツリー -> ステージ　-> リポジトリ

ワークツリー: 手元でファイルを変更する作業場
ステージ: コミットする変更を準備する場所 , スナップショットを記録する準備する場所(git add コマンド)
(コミット: スナップショットを記録すること)

## 何故、一旦ステージに追加するのか？
手元には、変更したファイル　, 変更していないファイルがある。
変更したファイルだけをスナップショットとして記録したい　, Githubにアップしたい
変更した分だけ記録できるよう、記録する変更ファイルをステージに追加して、ステージに追加された変更分だけリポジトリに記録する
(全ての変更ではなく、記録したい変更分だけ、記録できるようにする)
ステージに追加したその後に、スナップショットをリポジトリに記録する
このスナップショットの保管場所がリポジトリ 
スナップショットを記録することがコミット(git commit)

## Gitのデータの持ち方(コミットの流れ)
#### ステージに追加する際の裏側(ワークツリーにindex.htmlというファイルを作り、それをステージに追加する)

[![Image from Gyazo](https://i.gyazo.com/0f6ff1a45eb72219dfdcf06776724868.png)](https://gyazo.com/0f6ff1a45eb72219dfdcf06776724868)

- index.htmlのファイルを圧縮した圧縮ファイルAをリポジトリに追加する
- インデックスというファイルに、index.htmlというファイルを圧縮したのが圧縮ファイルAだと保存する
　　(ファイル名とファイルの中身をマッチングさせた情報を保存する)
 
###### これを行っているのがgit add

#### コミットする際の裏側
[![Image from Gyazo](https://i.gyazo.com/819092cc28ca002898ca356131dd88cb.png)](https://gyazo.com/819092cc28ca002898ca356131dd88cb)

インデックスのファイル構成を元に、ツリー1というファイルを作る
ツリー1は、インデックスに記載されているディレクトリのファイル構成を改めて保存したもの
コミット1というファイルを作る
コミット1には、ツリーのファイル名 , コミットした人のメールアドレスと名前 , コミットした日付, コミットメッセージが記録される
ツリー1からファイル構成つまり、ファイル名とそのファイル内容がわかる=>コミットした時のスナップショットがわかる
コミット1というファイルからその時のファイル状態と誰が、いつ、何のために変更したのかわかる

###### これを行っているのがgit commit

#### 新しいファイルを作った時の裏側

圧縮ファイルを作成する
インデックスに圧縮ファイルとその圧縮ファイルが何かを追記する(git add)
ツリーを新規作成する(今のインデックスの状態を保存する)
コミットを新規作成する(直前のコミットを親コミットとする)(変更履歴を辿れるため。)

#### ファイルを変更したら

変更したファイルにだけ、新たに圧縮ファイルを新規作成する
元々あった圧縮ファイルは、上書きされる
新しいツリーファイルを作成する
新しいコミットファイルを作成する

画像引用: 
[Gitのコミットの裏側で起こっていること
](https://made.livesense.co.jp/entry/2017/08/22/080000)

# gitを使ってみよう
git init: ローカルリポジトリを新規作成する

git initの中にあるもの(重要なもの)
objects: この中に、圧縮ファイル , ツリーファイル, コミットファイルが保存される
config: gitの設定ファイル

git clone リポジトリ名: Gitリポジトリのコピーを作成する

リモートリポジトリのファイルがワークツリーにコピーされる
リポジトリ(.git)がコピーされる 

git add ~ : 変更をステージに追加する

git commit ~  : 変更を記録する

コミットメッセージの書き方
簡単に書く時: 変更内容の要点と理由を1行で簡潔に書く
正式に書く時: 1行目: 変更内容の要約 , 2行目: 空行 , 3行目: 変更した理由

git status: インデックスの情報と今のワークツリーの情報を比べ、前回ステージに追加してから変更したワークツリーのファイルがわかる , ステージのインデックスと前回コミットした時のスナップショットを比べ、前回コミットした後にステージに追加されたファイルがわかる

git diff: git add する前の変更差分を確認する
git diff --staged: git addした後の変更分を確認する

git log: 変更履歴を確認する

git rm ~ : ファイルごと削除ファイルの削除を記録する, この変更は自動でステージに上げられる
git rm --cached ~ : ファイルを残しつつ、ファイルの削除を記録する(パスワードが載ったファイルを間違えてgit の記録にあげた時、それをgitから削除したいときに使う)

git mv 旧ファイル名 新ファイル名: ファイル名を変更する(ワークツリーにも反映される)
この変更は、ステージに追加されている

リモートリポジトリ(Github)を新規追加する
git remote add origin ~ : リモートリポジトリ(Github)を新規追加する 
originというショートカットで~というリモートリポジトリを登録する

originという名前でGithubリポジトリにアップしたり取得したりできる(urlをまた、打つ必要なし)
git push リモート名 ブランチ名 : リモートリポジトリ(Github)へ送信する

git push -u origin masterを使うことで、次回以降git push = git push origin masterとなる。

コマンドにエイリアスをつけると楽になる
git config --global alias.ci commit : commitというコマンドにciというエイリアスを割り当てる
git config --global alias.br brach : branchというコマンドにbrというエイリアスを割り当てる
git config --global alias.st status: statusというコマンドにstというエイリアスを割り当てる
git config --global alias.co checkout : checkoutというコマンドにcoというエイリアスを割り当てる

--global: PC全体に対する設定を行う際に使う

## gitでバージョン管理しない,Githubで公開させない方法(パスワードなど)

.gitignoreファイルに管理したくないファイルを指定する













  












