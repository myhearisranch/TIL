# リベースで変更履歴を修正しよう

## リベースする
リベース: 変更を統合する際に、履歴をきれいに整えるために使う
git rebase ブランチ名 : ブランチの基点となるコミットを別のコミットに移動する

[![Image from Gyazo](https://i.gyazo.com/177cde5d9d8d3358175ba9c405252677.png)](https://gyazo.com/177cde5d9d8d3358175ba9c405252677)

git rebase ~ によって、featureブランチがmasterブランチの前に移動する<br>
親コミットが2に変わった => masterブランチの変更分(コミット2の変更分)がfeatureブランチに取り込まれた

## リベースでしてはいけないこと
GithubにプッシュしたコミットをリベースするのはNG

[![Image from Gyazo](https://i.gyazo.com/9eee2d965e3316f4f80709324439c89e.png)](https://gyazo.com/9eee2d965e3316f4f80709324439c89e)
GitHubにプッシュしたコミットをリベースすると、後にPushできなくなる
コミット1の次のコミットがローカルリポジトリとGithubで違うため

### git push -f は絶対NG

## リベースとマージのどちらを使う?
マージ: 作業の履歴を残したいならマージを使う
メリット: コンフリクトの解決が比較的簡単
デメリット: マージコミットがたくさんあると履歴が複雑化する

リベース:　履歴をきれいにしたいならリベースを使う
メリット: 履歴を綺麗に保てる
デメリット: コンフリクトの解決が若干面倒(コミットそれぞれに解消が必要)

## マージとリベースのコンフリクトの違い
マージ:
コミット2とコミット5での枝分かれ部分で、index.htmlの1行目を編集してるのでコンフリクトが起きる

リベース:
コミット2で、index.htmlの1行目を編集する , 枝分かれさせてコミット3で、index.htmlの1行目を編集する
コミット3を親コミットとして、コミット4でindex.htmlの1行目を編集する
コミット4にいる状態で、リベースしコミット3の親コミットをコミット2にすると、、、
コンフリクトがコミット3,4で発生する(コンフリクトが各コミットごとに発生する)
リベースに含まれるコミットが複数ある場合、それぞれのコミットごとにリベースを実行し全部のコミットのリベースが完了した時点でリベースが完了する

### プッシュしていないローカルの変更にはリベースを使い、プッシュした後はマージを使う<br>
### コンフリクトしそうならマージを使う

## プルするにはマージ型とリベース型がある
プルのマージ型: マージコミットが残るので、マージしたという記録を残したい場合に使う
git pull リモート名 ブランチ名 

プルのリベース型: マージコミットが残らないからGithubの内容を取得したいだけの時に使う
git pull --rebase リモート名 ブランチ名 
